"""
Enhanced image management for UI/UX lessons.
Provides a unified interface for getting images from multiple sources.
"""

import os
import random
import logging
import ssl
import certifi
import tempfile
import asyncio
from typing import Dict, Optional, Any, List
import base64
from urllib.parse import urlparse
from io import BytesIO
from pathlib import Path

import aiohttp
from openai import AsyncOpenAI
import httpx

from app.config import settings
from app.api import unsplash_client

# Configure logger
logger = logging.getLogger(__name__)

# Initialize OpenAI client with proper configuration
# Create httpx client with proper SSL verification settings first
http_client = httpx.AsyncClient(
    verify=not settings.DISABLE_SSL_VERIFICATION,
    timeout=httpx.Timeout(connect=5.0, read=30.0, write=30.0, pool=30.0)
)

# Initialize OpenAI client with the custom httpx client
openai_client = AsyncOpenAI(
    api_key=settings.OPENAI_API_KEY,
    http_client=http_client
)

class ImageStrategy:
    """Base class for image retrieval strategies"""
    async def get_image(self, theme: str) -> Optional[Dict[str, Any]]:
        raise NotImplementedError("Each strategy must implement get_image method")


class UnsplashStrategy(ImageStrategy):
    """Strategy to get images from Unsplash API"""
    async def get_image(self, theme: str) -> Optional[Dict[str, Any]]:
        return await unsplash_client.get_image_for_lesson(theme)


class OpenAIDALLEStrategy(ImageStrategy):
    """Strategy to generate images using OpenAI DALL-E API"""
    async def get_image(self, theme: str) -> Optional[Dict[str, Any]]:
        if not settings.OPENAI_API_KEY:
            logger.warning("OpenAI API key not available for DALL-E image generation")
            return None
            
        try:
            logger.info(f"Generating image with DALL-E for theme: {theme}")
            
            # Create a detailed prompt for DALL-E
            prompt = (
                f"A beautiful, professional UI/UX design focused on {theme}. "
                f"High-quality, suitable for a professional design lesson. "
                f"Clean, modern style with appropriate design elements."
            )
            
            # Try with DALL-E
            response = await openai_client.images.generate(
                model="dall-e-3" if hasattr(settings, "DALLE_MODEL") and settings.DALLE_MODEL == "dall-e-3" else "dall-e-2",
                prompt=prompt,
                n=1,
                size="1024x1024",
                quality="standard",
                response_format="url"
            )
            
            if response and response.data and len(response.data) > 0:
                image_url = response.data[0].url
                return {
                    "url": image_url,
                    "attribution": "Generated by DALL-E"
                }
                
        except Exception as e:
            logger.error(f"Error generating DALL-E image: {e}")
        
        return None


class PexelsStrategy(ImageStrategy):
    """Strategy to fetch images from Pexels API"""
    async def get_image(self, theme: str) -> Optional[Dict[str, Any]]:
        if not hasattr(settings, "PEXELS_API_KEY") or not settings.PEXELS_API_KEY:
            logger.warning("Pexels API key not available")
            return None
            
        try:
            logger.info(f"Fetching image from Pexels for theme: {theme}")
            search_term = f"ui ux {theme} design"
            url = "https://api.pexels.com/v1/search"
            
            params = {
                "query": search_term,
                "per_page": 1,
                "orientation": "landscape"
            }
            
            headers = {"Authorization": settings.PEXELS_API_KEY}
            
            # Create SSL context with proper certificate verification
            ssl_context = ssl.create_default_context(cafile=certifi.where())
            
            # Set verify_ssl based on environment
            verify_ssl = not getattr(settings, 'DISABLE_SSL_VERIFICATION', False)
            
            connector = aiohttp.TCPConnector(ssl=ssl_context if verify_ssl else False)
            async with aiohttp.ClientSession(connector=connector) as session:
                async with session.get(url, headers=headers, params=params, timeout=settings.REQUEST_TIMEOUT) as response:
                    if response.status == 200:
                        data = await response.json()
                        if data.get("photos") and len(data["photos"]) > 0:
                            image_url = data["photos"][0]["src"]["large"]
                            photographer = data["photos"][0]["photographer"]
                            attribution = f"Photo by {photographer} on Pexels"
                            return {"url": image_url, "attribution": attribution}
        except Exception as e:
            logger.error(f"Error fetching Pexels image: {e}")
        
        return None


class LocalFallbackStrategy(ImageStrategy):
    """Strategy to use local fallback images"""
    async def get_image(self, theme: str) -> Optional[Dict[str, Any]]:
        return unsplash_client.get_local_fallback_image()


class ImageManager:
    """Manager class that organizes multiple image sources with fallback logic"""
    
    def __init__(self):
        self.strategies = {}
        self.strategy_order = []
        
        # Initialize all available strategies
        if settings.OPENAI_API_KEY and getattr(settings, "ENABLE_DALLE_IMAGES", False):
            self.strategies["dalle"] = OpenAIDALLEStrategy()
        
        if settings.UNSPLASH_API_KEY:
            self.strategies["unsplash"] = UnsplashStrategy()
            
        if hasattr(settings, "PEXELS_API_KEY") and settings.PEXELS_API_KEY:
            self.strategies["pexels"] = PexelsStrategy()
            
        # Always add local fallback
        self.strategies["local"] = LocalFallbackStrategy()
        
        # Set up the strategy order based on settings.IMAGE_PREFERENCE
        self._configure_strategy_order()
        
        # Log available strategies
        logger.info(f"Available image strategies: {list(self.strategies.keys())}")
        logger.info(f"Image strategy order: {self.strategy_order}")
        
    def _configure_strategy_order(self):
        """Configure the order in which strategies are tried"""
        try:
            # Default order if not specified in settings
            default_order = ["dalle", "unsplash", "pexels", "local"]
            
            # Get the preference order from settings
            if hasattr(settings, "IMAGE_PREFERENCE") and settings.IMAGE_PREFERENCE:
                preference_order = settings.IMAGE_PREFERENCE.lower().split(',')
                # Filter out any preferences that aren't available
                self.strategy_order = [p.strip() for p in preference_order if p.strip() in self.strategies]
                
                # If any strategies are missing from the preference list, add them to the end
                for strategy_name in self.strategies:
                    if strategy_name not in self.strategy_order:
                        self.strategy_order.append(strategy_name)
            else:
                # Use default order, filtered by available strategies
                self.strategy_order = [s for s in default_order if s in self.strategies]
        except Exception as e:
            logger.error(f"Error configuring strategy order: {e}. Using fallback order.")
            # Fallback to a simple order based on what's available
            self.strategy_order = list(self.strategies.keys())
            # Ensure local is last if it exists
            if "local" in self.strategy_order:
                self.strategy_order.remove("local")
                self.strategy_order.append("local")
    
    async def get_image_for_lesson(self, theme: str) -> Optional[Dict[str, Any]]:
        """Get an image for a lesson using multiple strategies with fallback"""
        logger.info(f"Getting image for theme: {theme}")
        
        # Try strategies in the configured order
        for strategy_name in self.strategy_order:
            if strategy_name in self.strategies:
                try:
                    logger.info(f"Trying {strategy_name} strategy for theme: {theme}")
                    image_data = await self.strategies[strategy_name].get_image(theme)
                    if image_data:
                        logger.info(f"Successfully got image from {strategy_name} for theme: {theme}")
                        # Add metadata about the source
                        image_data["source"] = strategy_name
                        return image_data
                except Exception as e:
                    logger.error(f"Error using {strategy_name} strategy: {e}")
                    continue
        
        logger.warning(f"Failed to get image for theme: {theme} from any source")
        return None
        
    async def save_image_locally(self, image_url: str) -> Optional[str]:
        """Download an image from URL and save it locally"""
        if not image_url:
            return None
            
        try:
            # Parse URL to get filename
            parsed_url = urlparse(image_url)
            filename = os.path.basename(parsed_url.path)
            
            # If filename is empty or invalid, generate a random one
            if not filename or len(filename) < 5:
                filename = f"image_{random.randint(1000, 9999)}.jpg"
                
            # Ensure the filename has an extension
            if not os.path.splitext(filename)[1]:
                filename += ".jpg"
                
            # Create a path in the fallback images directory
            image_path = os.path.join(settings.FALLBACK_IMAGES_DIR, filename)
            
            # Create SSL context with proper certificate verification
            ssl_context = ssl.create_default_context(cafile=certifi.where())
            
            # Set verify_ssl based on environment
            verify_ssl = not getattr(settings, 'DISABLE_SSL_VERIFICATION', False)
            
            # Download the image
            connector = aiohttp.TCPConnector(ssl=ssl_context if verify_ssl else False)
            async with aiohttp.ClientSession(connector=connector) as session:
                async with session.get(image_url, timeout=settings.REQUEST_TIMEOUT) as response:
                    if response.status == 200:
                        with open(image_path, 'wb') as f:
                            f.write(await response.read())
                        return image_path
        except Exception as e:
            logger.error(f"Error saving image locally: {e}")
            
        return None

# Create a singleton instance
image_manager = ImageManager()

# Expose the main function for getting images
async def get_image_for_lesson(theme: str) -> Optional[Dict[str, Any]]:
    """Get a relevant image for the lesson using multiple sources with fallback"""
    return await image_manager.get_image_for_lesson(theme) 