"""
Enhanced image management for UI/UX lessons.
Provides a unified interface for getting images from multiple sources.
"""

import os
import random
import logging
import ssl
import certifi
import tempfile
import asyncio
from typing import Dict, Optional, Any, List
import base64
from urllib.parse import urlparse
from io import BytesIO
from pathlib import Path

import aiohttp
from openai import AsyncOpenAI

from app.config import settings
from app.api import unsplash_client

# Configure logger
logger = logging.getLogger(__name__)

# Initialize OpenAI client
openai_client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)

class ImageStrategy:
    """Base class for image retrieval strategies"""
    async def get_image(self, theme: str) -> Optional[Dict[str, Any]]:
        raise NotImplementedError("Each strategy must implement get_image method")


class UnsplashStrategy(ImageStrategy):
    """Strategy to get images from Unsplash API"""
    async def get_image(self, theme: str) -> Optional[Dict[str, Any]]:
        return await unsplash_client.get_image_for_lesson(theme)


class OpenAIDALLEStrategy(ImageStrategy):
    """Strategy to generate images using OpenAI DALL-E API"""
    async def get_image(self, theme: str) -> Optional[Dict[str, Any]]:
        if not settings.OPENAI_API_KEY:
            logger.warning("OpenAI API key not available for DALL-E image generation")
            return None
            
        try:
            logger.info(f"Generating image with DALL-E for theme: {theme}")
            
            # Create a detailed prompt for DALL-E
            prompt = (
                f"A beautiful, professional UI/UX design focused on {theme}. "
                f"High-quality, suitable for a professional design lesson. "
                f"Clean, modern style with appropriate design elements."
            )
            
            # Try with DALL-E
            response = await openai_client.images.generate(
                model="dall-e-3" if hasattr(settings, "DALLE_MODEL") and settings.DALLE_MODEL == "dall-e-3" else "dall-e-2",
                prompt=prompt,
                n=1,
                size="1024x1024",
                quality="standard",
                response_format="url"
            )
            
            if response and response.data and len(response.data) > 0:
                image_url = response.data[0].url
                return {
                    "url": image_url,
                    "attribution": "Generated by DALL-E"
                }
                
        except Exception as e:
            logger.error(f"Error generating DALL-E image: {e}")
        
        return None


class PexelsStrategy(ImageStrategy):
    """Strategy to fetch images from Pexels API"""
    async def get_image(self, theme: str) -> Optional[Dict[str, Any]]:
        if not hasattr(settings, "PEXELS_API_KEY") or not settings.PEXELS_API_KEY:
            logger.warning("Pexels API key not available")
            return None
            
        try:
            logger.info(f"Fetching image from Pexels for theme: {theme}")
            search_term = f"ui ux {theme} design"
            url = "https://api.pexels.com/v1/search"
            
            params = {
                "query": search_term,
                "per_page": 1,
                "orientation": "landscape"
            }
            
            headers = {"Authorization": settings.PEXELS_API_KEY}
            
            # Create SSL context with proper certificate verification
            ssl_context = ssl.create_default_context(cafile=certifi.where())
            
            # Set verify_ssl based on environment
            verify_ssl = not getattr(settings, 'DISABLE_SSL_VERIFICATION', False)
            
            connector = aiohttp.TCPConnector(ssl=ssl_context if verify_ssl else False)
            async with aiohttp.ClientSession(connector=connector) as session:
                async with session.get(url, headers=headers, params=params, timeout=settings.REQUEST_TIMEOUT) as response:
                    if response.status == 200:
                        data = await response.json()
                        if data.get("photos") and len(data["photos"]) > 0:
                            image_url = data["photos"][0]["src"]["large"]
                            photographer = data["photos"][0]["photographer"]
                            attribution = f"Photo by {photographer} on Pexels"
                            return {"url": image_url, "attribution": attribution}
        except Exception as e:
            logger.error(f"Error fetching Pexels image: {e}")
        
        return None


class LocalFallbackStrategy(ImageStrategy):
    """Strategy to use local fallback images"""
    async def get_image(self, theme: str) -> Optional[Dict[str, Any]]:
        return unsplash_client.get_local_fallback_image()


class ImageManager:
    """Manager class that organizes multiple image sources with fallback logic"""
    
    def __init__(self):
        self.strategies: List[ImageStrategy] = []
        
        # Configure the strategies based on available API keys and settings
        # Add DALL-E if OpenAI API key is available and DALL-E is enabled
        dalle_enabled = getattr(settings, "ENABLE_DALLE_IMAGES", False)
        if settings.OPENAI_API_KEY and dalle_enabled:
            self.strategies.append(OpenAIDALLEStrategy())
        
        # Add Unsplash if API key is available
        if settings.UNSPLASH_API_KEY:
            self.strategies.append(UnsplashStrategy())
            
        # Add Pexels if API key is available
        if hasattr(settings, "PEXELS_API_KEY") and settings.PEXELS_API_KEY:
            self.strategies.append(PexelsStrategy())
            
        # Always add local fallback as last resort
        self.strategies.append(LocalFallbackStrategy())
    
    async def get_image_for_lesson(self, theme: str) -> Optional[Dict[str, Any]]:
        """Get an image for a lesson using multiple strategies with fallback"""
        logger.info(f"Getting image for theme: {theme}")
        
        # Try each strategy in order until one succeeds
        for strategy in self.strategies:
            image_data = await strategy.get_image(theme)
            if image_data:
                return image_data
        
        logger.warning(f"Failed to get image for theme: {theme} from any source")
        return None
        
    async def save_image_locally(self, image_url: str) -> Optional[str]:
        """Download an image from URL and save it locally"""
        if not image_url:
            return None
            
        try:
            # Parse URL to get filename
            parsed_url = urlparse(image_url)
            filename = os.path.basename(parsed_url.path)
            
            # If filename is empty or invalid, generate a random one
            if not filename or len(filename) < 5:
                filename = f"image_{random.randint(1000, 9999)}.jpg"
                
            # Ensure the filename has an extension
            if not os.path.splitext(filename)[1]:
                filename += ".jpg"
                
            # Create a path in the fallback images directory
            image_path = os.path.join(settings.FALLBACK_IMAGES_DIR, filename)
            
            # Create SSL context with proper certificate verification
            ssl_context = ssl.create_default_context(cafile=certifi.where())
            
            # Set verify_ssl based on environment
            verify_ssl = not getattr(settings, 'DISABLE_SSL_VERIFICATION', False)
            
            # Download the image
            connector = aiohttp.TCPConnector(ssl=ssl_context if verify_ssl else False)
            async with aiohttp.ClientSession(connector=connector) as session:
                async with session.get(image_url, timeout=settings.REQUEST_TIMEOUT) as response:
                    if response.status == 200:
                        with open(image_path, 'wb') as f:
                            f.write(await response.read())
                        return image_path
        except Exception as e:
            logger.error(f"Error saving image locally: {e}")
            
        return None

# Create a singleton instance
image_manager = ImageManager()

# Expose the main function for getting images
async def get_image_for_lesson(theme: str) -> Optional[Dict[str, Any]]:
    """Get a relevant image for the lesson using multiple sources with fallback"""
    return await image_manager.get_image_for_lesson(theme) 