/**
 * Enhanced image management for UI/UX lessons.
 * Provides a unified interface for getting images from multiple sources.
 */

import fs from 'fs';
import path from 'path';
import { promisify } from 'util';
import axios from 'axios';
import { randomUUID } from 'crypto';
import { createWriteStream } from 'fs';
import { pipeline } from 'stream';
import { getChildLogger } from '../utils/logger';
import { settings, ImageSource, IMAGES_DIR, FALLBACK_IMAGES_DIR } from '../config/settings';
import { OpenAI } from 'openai';
import * as unsplashClient from '../api/unsplash-client';

// Configure logger
const logger = getChildLogger('image-manager');

// Promisify pipeline for async/await usage
const pipelineAsync = promisify(pipeline);

// Create images directory if it doesn't exist
const createImagesDir = () => {
  if (!fs.existsSync(IMAGES_DIR)) {
    fs.mkdirSync(IMAGES_DIR, { recursive: true });
    logger.info(`Created images directory: ${IMAGES_DIR}`);
  }
  
  const generatedImagesDir = path.join(IMAGES_DIR, 'generated');
  if (!fs.existsSync(generatedImagesDir)) {
    fs.mkdirSync(generatedImagesDir, { recursive: true });
    logger.info(`Created generated images directory: ${generatedImagesDir}`);
  }
};

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: settings.OPENAI_API_KEY,
  timeout: settings.REQUEST_TIMEOUT * 1000,
});

/**
 * Interface for image details returned by strategies
 */
interface ImageDetails {
  url: string;
  alt_text?: string;
  source?: string;
  author?: string;
  local_path?: string;
}

/**
 * Base strategy interface for image retrieval
 */
interface ImageStrategy {
  getImage(theme: string): Promise<ImageDetails | null>;
}

/**
 * Strategy to get images from Unsplash API
 */
class UnsplashStrategy implements ImageStrategy {
  async getImage(theme: string): Promise<ImageDetails | null> {
    try {
      if (!settings.UNSPLASH_API_KEY) {
        logger.warn('Unsplash API key not set, skipping Unsplash strategy');
        return null;
      }
      
      const imageData = await unsplashClient.searchImage(theme);
      
      if (!imageData || !imageData.url) {
        logger.warn(`No Unsplash image found for theme: ${theme}`);
        return null;
      }
      
      return {
        url: imageData.url,
        alt_text: imageData.alt_text || `UI/UX illustration for ${theme}`,
        source: 'Unsplash',
        author: imageData.author,
      };
    } catch (error) {
      logger.error(`Error getting Unsplash image: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
}

/**
 * Strategy to get images from OpenAI DALL-E
 */
class OpenAIDALLEStrategy implements ImageStrategy {
  async getImage(theme: string): Promise<ImageDetails | null> {
    try {
      if (!settings.ENABLE_DALLE_IMAGES) {
        logger.warn('DALL-E image generation is disabled, skipping DALL-E strategy');
        return null;
      }
      
      // Generate a prompt for the image
      const prompt = `A professional UI/UX design illustration related to "${theme}". Create an image that would be suitable for an educational article about this UI/UX concept. Use a clean, modern design style with a balanced color palette.`;
      
      logger.info(`Generating DALL-E image with prompt: ${prompt}`);
      
      const response = await openai.images.generate({
        model: settings.DALLE_MODEL,
        prompt: prompt,
        n: 1,
        size: '1024x1024',
      });
      
      const imageUrl = response.data[0]?.url;
      
      if (!imageUrl) {
        logger.warn(`DALL-E did not return an image for theme: ${theme}`);
        return null;
      }
      
      return {
        url: imageUrl,
        alt_text: `UI/UX illustration for ${theme} generated by DALL-E`,
        source: 'DALL-E',
      };
    } catch (error) {
      logger.error(`Error generating DALL-E image: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
}

/**
 * Strategy to get images from Pexels API
 */
class PexelsStrategy implements ImageStrategy {
  async getImage(theme: string): Promise<ImageDetails | null> {
    try {
      if (!settings.PEXELS_API_KEY) {
        logger.warn('Pexels API key not set, skipping Pexels strategy');
        return null;
      }
      
      const searchTerm = `UI/UX ${theme}`;
      logger.info(`Searching Pexels for: ${searchTerm}`);
      
      const response = await axios.get('https://api.pexels.com/v1/search', {
        params: {
          query: searchTerm,
          per_page: 1,
        },
        headers: {
          Authorization: settings.PEXELS_API_KEY,
        },
        timeout: settings.REQUEST_TIMEOUT * 1000,
      });
      
      const photos = response.data.photos;
      
      if (!photos || photos.length === 0) {
        logger.warn(`No Pexels image found for theme: ${theme}`);
        return null;
      }
      
      const photo = photos[0];
      
      return {
        url: photo.src.large2x,
        alt_text: photo.alt || `UI/UX illustration for ${theme}`,
        source: 'Pexels',
        author: photo.photographer,
      };
    } catch (error) {
      logger.error(`Error getting Pexels image: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
}

/**
 * Strategy to use local fallback images
 */
class LocalFallbackStrategy implements ImageStrategy {
  async getImage(theme: string): Promise<ImageDetails | null> {
    try {
      // Ensure fallback directory exists
      if (!fs.existsSync(FALLBACK_IMAGES_DIR)) {
        logger.warn(`Fallback images directory not found: ${FALLBACK_IMAGES_DIR}`);
        return null;
      }
      
      // Get all .jpg, .png files in the fallback directory
      const files = fs.readdirSync(FALLBACK_IMAGES_DIR)
        .filter(file => file.match(/\.(jpg|jpeg|png)$/i));
      
      if (files.length === 0) {
        logger.warn('No fallback images found');
        return null;
      }
      
      // Select a random image
      const randomImage = files[Math.floor(Math.random() * files.length)];
      const imagePath = path.join(FALLBACK_IMAGES_DIR, randomImage);
      
      return {
        url: `file://${imagePath}`,
        alt_text: `UI/UX illustration for ${theme}`,
        source: 'Local',
        local_path: imagePath,
      };
    } catch (error) {
      logger.error(`Error getting local fallback image: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
}

// Record type for strategies
interface StrategyRecord {
  [key: string]: ImageStrategy;
}

/**
 * Main image manager class that coordinates image retrieval strategies
 */
export class ImageManager {
  private strategies: StrategyRecord = {};
  private strategyOrder: ImageSource[] = [];
  
  constructor() {
    // Create images directory if it doesn't exist
    createImagesDir();
    
    // Configure strategies
    this.strategies = {
      'dalle': new OpenAIDALLEStrategy(),
      'unsplash': new UnsplashStrategy(),
      'pexels': new PexelsStrategy(),
      'local': new LocalFallbackStrategy(),
    };
    
    // Configure strategy order from settings
    this.configureStrategyOrder();
  }
  
  /**
   * Configure the order in which strategies are tried
   */
  private configureStrategyOrder(): void {
    // Default order
    this.strategyOrder = ['dalle', 'unsplash', 'pexels', 'local'];
    
    // If IMAGE_PREFERENCE is set, use that order
    if (settings.IMAGE_PREFERENCE && settings.IMAGE_PREFERENCE.length > 0) {
      this.strategyOrder = settings.IMAGE_PREFERENCE;
    }
    
    logger.info(`Image strategy order: ${this.strategyOrder.join(', ')}`);
  }
  
  /**
   * Get an image for a lesson
   * 
   * @param theme - The theme of the lesson
   * @returns The image details if found, null otherwise
   */
  async getImageForLesson(theme: string): Promise<ImageDetails | null> {
    for (const strategyName of this.strategyOrder) {
      logger.info(`Trying image strategy: ${strategyName} for theme: ${theme}`);
      
      const strategy = this.strategies[strategyName];
      if (!strategy) {
        logger.warn(`Strategy not found: ${strategyName}`);
        continue;
      }
      
      const imageDetails = await strategy.getImage(theme);
      
      if (imageDetails) {
        logger.info(`Found image using strategy: ${strategyName}`);
        
        // Return image details directly, without saving locally
        if (imageDetails.url) {
          return imageDetails;
        }
      }
    }
    
    logger.warn(`No image found for theme: ${theme} after trying all strategies`);
    return null;
  }
  
  /**
   * Save an image from a URL to the local filesystem
   * 
   * @param imageUrl - The URL of the image to save
   * @returns The local path to the saved image if successful, null otherwise
   */
  async saveImageLocally(imageUrl: string): Promise<string | null> {
    try {
      // Ensure images directory exists
      createImagesDir();
      
      // Create a unique filename for the image
      const fileExtension = this.getFileExtensionFromUrl(imageUrl);
      const filename = `${randomUUID()}${fileExtension}`;
      const savePath = path.join(IMAGES_DIR, 'generated', filename);
      
      logger.info(`Saving image to: ${savePath}`);
      
      // Download the image
      const response = await axios({
        method: 'get',
        url: imageUrl,
        responseType: 'stream',
        timeout: settings.REQUEST_TIMEOUT * 1000,
      });
      
      // Save the image to a file
      const writer = createWriteStream(savePath);
      await pipelineAsync(response.data, writer);
      
      logger.info(`Successfully saved image to: ${savePath}`);
      
      // Verify the file was saved correctly by checking its existence and size
      if (fs.existsSync(savePath)) {
        const stats = fs.statSync(savePath);
        if (stats.size === 0) {
          // File was created but is empty
          logger.error(`Saved image file is empty: ${savePath}`);
          return null;
        }
        
        // Return the absolute path to the file
        return path.resolve(savePath);
      } else {
        logger.error(`File was not created: ${savePath}`);
        return null;
      }
    } catch (error) {
      logger.error(`Error saving image locally: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }

  /**
   * Get file extension from URL or default to .png
   * 
   * @param url - The URL to extract extension from
   * @returns The file extension including the dot
   */
  private getFileExtensionFromUrl(url: string): string {
    try {
      const urlObj = new URL(url);
      const pathname = urlObj.pathname;
      const extension = path.extname(pathname);
      
      // If we have a valid extension, use it, otherwise default to .png
      return extension && extension.length > 1 ? extension : '.png';
    } catch (error) {
      // If URL parsing fails, default to .png
      return '.png';
    }
  }
}

// Singleton instance of the image manager
const imageManagerInstance = new ImageManager();

/**
 * Get an image for a lesson
 * 
 * @param theme - The theme of the lesson
 * @returns The image details if found, null otherwise
 */
export async function getImageForLesson(theme: string): Promise<ImageDetails | null> {
  return imageManagerInstance.getImageForLesson(theme);
}

export { ImageDetails };

export default {
  getImageForLesson,
  ImageManager,
};

/**
 * Get an image for a UI/UX topic
 * Uses existing image fetching functionality without caching
 * @param theme The UI/UX theme to get an image for
 * @returns URL of the image, or null if not found
 */
export async function getUIUXImage(theme: string): Promise<string | null> {
  logger.info(`Getting image for UI/UX theme: ${theme}`);
  
  try {
    // Use the existing image getter function
    const imageDetails = await getImageForLesson(`UI/UX ${theme}`);
    return imageDetails?.url || null;
  } catch (error) {
    logger.error(`Error getting image for ${theme}: ${error instanceof Error ? error.message : String(error)}`);
    return 'https://placehold.co/600x400/FFFFFF/808080?text=UI/UX+Design'; // Fallback image
  }
}

/**
 * Get an image from DALL-E
 * @param theme The theme to generate an image for
 * @returns URL of the generated image, or null if not available
 */
async function getDalleImage(theme: string): Promise<string | null> {
  if (!settings.OPENAI_API_KEY) {
    logger.warn('OpenAI API key not configured, skipping DALL-E image generation');
    return null;
  }
  
  try {
    const dalleStrategy = new OpenAIDALLEStrategy();
    const imageDetails = await dalleStrategy.getImage(`UI/UX design concept for ${theme}`);
    return imageDetails?.url || null;
  } catch (error) {
    logger.error(`Error generating DALL-E image: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Get an image from Unsplash
 * @param theme The theme to search for
 * @returns URL of the image, or null if not available
 */
async function getUnsplashImage(theme: string): Promise<string | null> {
  if (!settings.UNSPLASH_API_KEY) {
    logger.warn('Unsplash API key not configured, skipping Unsplash image search');
    return null;
  }
  
  try {
    const unsplashStrategy = new UnsplashStrategy();
    const imageDetails = await unsplashStrategy.getImage(`UI/UX ${theme}`);
    return imageDetails?.url || null;
  } catch (error) {
    logger.error(`Error getting Unsplash image: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Get an image from Pexels
 * @param theme The theme to search for
 * @returns URL of the image, or null if not available
 */
async function getPexelsImage(theme: string): Promise<string | null> {
  if (!settings.PEXELS_API_KEY) {
    logger.warn('Pexels API key not configured, skipping Pexels image search');
    return null;
  }
  
  try {
    const pexelsStrategy = new PexelsStrategy();
    const imageDetails = await pexelsStrategy.getImage(`UI/UX ${theme}`);
    return imageDetails?.url || null;
  } catch (error) {
    logger.error(`Error getting Pexels image: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Get a local image
 * @returns URL of the image, or null if not available
 */
async function getLocalImage(): Promise<string | null> {
  try {
    const localStrategy = new LocalFallbackStrategy();
    const imageDetails = await localStrategy.getImage('');
    return imageDetails?.url || null;
  } catch (error) {
    logger.error(`Error getting local image: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Get a fallback image when no other sources are available
 * @returns URL of a fallback image
 */
function getFallbackImage(): string {
  // Default to a generic UI/UX design image path
  return 'https://placehold.co/600x400/FFFFFF/808080?text=UI/UX+Design';
} 